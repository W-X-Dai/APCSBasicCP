\section{STL}
    雖然至今為止我們都當作你們已經會使用STL了。
    不過可能有一些同學甚至還不知道我在講什麼。
    所以我決定加上這個小節，告訴大家什麼是STL。

    \textbf{不過其實這個章節的作者是戴偉璿}

    \author{戴偉璿}

    \subsection{什麼是STL}

    想像一個狀況，你今天想要使用電腦，那你會怎麼做？
    零零散散購買主機板、CPU、記憶體、顯示卡、硬碟等等自己組裝固然可以，但直接購買一台完整的電腦是否比較方便？
    STL就是這樣的東西。
    STL是\texttt{C++}的標準模板庫（Standard Template Library），
    它提供了一些常用的資料結構，讓我們可以更方便地使用\texttt{C++}進行程式設計。

    STL的目的是為了讓我們可以更快速地開發程式，而不需要從頭開始實作所有的資料結構和演算法。
    白話來說，他其實就是把東西打包好方便我們使用。
    
    以下逐一介紹STL的各種資料結構。
    
    \subsection{string}
    \texttt{string}是\texttt{C++}中用來處理字串的資料結構，你可以把他看成是一個字元陣列，
    但它提供了更多的功能，例如自動管理記憶體、支援字串操作等。
    \texttt{string}的使用方式與陣列類似，但它有一些特別的功能，例如可以自動調整大小、支援字串連接等。
    \newpage
    以下是一些常用的\texttt{string}操作：

    \begin{lstlisting}[caption=string 用法]
    // declare 宣告
    string s;

    // give value 輸入
    cin>>s;
    getline(cin,s); 

    // 取得某一個位置的值，和陣列一樣
    s[5];

    // size 長度
    // good
    cout<<s.size()<<s.length();
    // bad
    cout<<strlen(s);

    // clear 清空
    s.clear();
    
    // 連接
    string s1="abc",s2="def";
    s=s1+s2;
    \end{lstlisting}

    在使用\texttt{string}時，請注意以下幾點：
    \begin{itemize}
        \item \texttt{string}的大小可以動態調整，不需要預先指定大小。
        \item \texttt{string}支援字串操作，例如連接、比較、搜尋等。
        \item 在取得字串長度時，不建議使用\texttt{strlen()}，因為他的的時間複雜度是\(\mathcal{O}(n)\)，
        而\texttt{string}的\texttt{size()}和\texttt{length()}方法的時間複雜度是\(\mathcal{O}(1)\)。
        \item \texttt{string}的字元編碼是\texttt{UTF-8}，所以可以處理多種語言的字串。
    \end{itemize}
    \subsection{vector}

    \texttt{vector}是\texttt{C++}中用來處理動態陣列的資料結構，
    它提供了自動管理記憶體的功能，並且支援隨機存取。
    \texttt{vector}的使用方式與陣列類似，但它有一些特別的功能，例如可以自動調整大小、支援插入和刪除等。
    \newpage
    以下是一些常用的\texttt{vector}操作：
    \begin{lstlisting}[caption=vector 用法]
    // declare 宣告
    vector<int> v;
    vector<char> v[10005];// 這樣宣告的是10005個vector，可以看成是二維陣列
    // 而不是內有10005個元素的vector
    // 如果需要宣告有10005個元素的vector
    vector<int> v(10005);
    vector<int> v(10005,-1); // 所有元素皆為-1

    // add element 新增元素
    // faster 因為使用建構式而非複製。
    v.emplace_back(x);
    // slower
    v.push_back(x);

    // erase back 從最後一個移除元素
    v.pop_back()

    // go through 遍歷
    for(auto i:v){
        // i:the elements of vector v
    }

    // size
    v.size()
        
    // clear
    v.clear();
    \end{lstlisting}

    \subsection{stack}

\begin{lstlisting}[caption=stack 用法]
// declare 宣告
stack<int> st;
stack<char> st;
// faster
stack<int,vector<int>> st;

// add element to back 就是 push_back()
st.push(x);
st.emplace(x); // emplace_back() in vector

// query the last element 頂部元素
st.top();

// move out the last element 移除頂部元素
st.pop();

// check is empty
st.empty();

// size
st.size()
\end{lstlisting}

    \subsection{queue}

\begin{lstlisting}[caption=queue 用法]
// declare
queue<int> qu;

// add element to back
qu.push(x);

// query the first element
qu.front();

// move out the last element
qu.pop();

// check is empty
qu.empty();

// size
qu.size()
\end{lstlisting}

    \subsection{deque}

    雙端佇列，上一章有用到。

\begin{lstlisting}[caption=deque 用法]
// declare
deque<int> dq;

// add element to back
dq.push_back(x);
dq.push_front(x);

// query the last element
dq.front();
dq.back();

// move out the last element
dq.pop_back();
dq.pop_front();

// 也可以像陣列一樣用
dq[10];

// check is empty
dq.empty();

// size
dq.size()
\end{lstlisting}

    \subsection{priority queue}

    本質上是一個使用vector維護的heap資料結構。

\begin{lstlisting}[caption=priority queue 用法]
// declare (最大堆)
priority_queue<int> pq;
// 最小堆
priority_queue<int,vector<int>,greater<int>> pq;

// add element into the pq
pq.push(x);

// query the element (對最大堆來說就是最大值)
// (對最小堆來說就是最小值)
pq.top();

// move out the max/min element
pq.pop();

// check is empty
pq.empty()
    
// size
pq.size()
\end{lstlisting}

    \subsection{map}
    map與set都是使用紅黑樹實作的資料結構，那是一種稱為平衡樹的資料結構。
    未來在進階資料結構時會提到一種稱為Treap的平衡樹。

\begin{lstlisting}[caption=map 用法]
// declare
map<int,int> mp;
// 兩個可以不一樣
map<string,int> mp;

// add element into mp (key 為 y，value 為 x)
mp.insert({y,x});
mp.emplace(y,x);
mp[y]=x;

// query the element
mp[y];
mp.begin();
mp.end();

// move out the element (key 為 x)
mp.erase(x);

// check the element with key x is present in the map container

// return int (但只有 0, 1)
mp.count(x)

// return iterator
map<int,int>::iterator it=mp.find(x)

// check is empty
mp.empty()
        
// size
mp.size()
\end{lstlisting}

    \subsection{set}

\begin{lstlisting}[caption=set 用法]
// declare
set<int> S;

// add element to back
S.insert(x);
S[y]=x;

// query the element
S[y]
S.begin();
S.end();

// check the x is in the set
// return iterator
set<int>::iterator it=S.find(x)
//return
S.count(x)

// 找出不小於x的最小值
it=S.lower_bound(x);
// 找出大於x的最小值
it=S.upper_bound(x);
// move out the last element
S.erase(x);

// check is empty
S.empty()
    
// size
S.size()
\end{lstlisting}

    \subsection{bitset}
    bitset在做位元運算時會比bool陣列快上許多。
    所以有時候會用到，但真的很少需要它。

\begin{lstlisting}[caption=bitset 用法]
// declare
bitset<100010> bt;

// give value
string str;
cin>>str;
bt=bitset<100010>(str);

// find one index 存取
bt[5];

// set all element to 0
bt.reset();

// set all element to 1
bt.set();

// bitwise operation
bitset<10> a,b;
for(auto &i:a) cin>>i;
for(auto &i:b) cin>>i;

cout<<a&b<<"\n";
cout<<a|b<<"\n";
cout<<a^b<<"\n";
\end{lstlisting}

    \subsection{小節}
    這個章節基本上都是背誦的內容，但是其實用性非常高，
    建議同學藉由實作上多多使用這些東西來熟悉STL們。

    \begin{tip}
        不要用背的，而是藉由不斷的使用讓大腦自然地記起來。
    \end{tip}

    \subsection{範例與練習}

    \problem LeetCode 3. Longest Substring Without Repeating Characters

    \textbf{題目敘述}

    給你一個字串 s，找出最長的子字串滿足裡面沒有相同的字母。

    \textbf{輸入說明}

    $0 \le s.length \le 5 \times 10^4$
    s裡面可能有空格。
    
    \textbf{輸出說明}

    輸出長度。

    \textbf{範例測試}

    \begin{tabular}{|m{7cm}|m{7cm}|}
        \hline
        範例輸入 1 & 範例輸出 1 \\
        \hline
        \verb|abcabcbb| & \verb|3| \\
        \hline
        範例輸入 2 & 範例輸出 2 \\
        \hline
        \verb|bbbbb| & \verb|1| \\
        \hline
        範例輸入 3 & 範例輸出 3 \\
        \hline
        \verb|pwwkew| & \verb|3|\\
        \hline
    \end{tabular}